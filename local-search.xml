<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AI notes</title>
    <link href="/2024/10/07/AI%20notes/"/>
    <url>/2024/10/07/AI%20notes/</url>
    
    <content type="html"><![CDATA[<h4 id="通道注意力"><a href="#通道注意力" class="headerlink" title="通道注意力"></a>通道注意力</h4><p>通道注意力关注的是图像的通道维度，即不同颜色通道之间的关系，为每个通道赋予不同的权重值。<br>输入特征图的尺寸为 𝐻×𝑊×𝐶 ，其中𝐻是高度，𝑊是宽度，𝐶是通道数。<br>经过池化得到特征图，用全连接层计算每个通道的权重，之后将每个通道的特征乘以相应的权重。<br>从而增强重要特征并抑制不重要特征。<br>尺寸变化: [H, W, C] x [1, 1, C] &#x3D; [H, W, C]  </p><h4 id="空间注意力"><a href="#空间注意力" class="headerlink" title="空间注意力"></a>空间注意力</h4><p>CBAM全称Convolutional Block Attention Module，这是一种用于前馈卷积神经网络的简单而有效的注意模块。是传统的通道注意力机制+空间注意力机制，是 channel(通道) + spatial(空间) 的统一<br>由于CBAM是轻量级的通用模块，因此可以以可忽略的开销将其无缝集成到任何CNN架构中，并且可以与基础CNN一起进行端到端训练。<br>空间注意力模型就是寻找网络中最重要的部位进行处理，空间注意力旨在提升关键区域的特征表达。  </p><h4 id="CBAM结构如图所示"><a href="#CBAM结构如图所示" class="headerlink" title="CBAM结构如图所示"></a>CBAM结构如图所示</h4><p>其中，先降维，再升维的操作：压缩激励机制  </p><h4 id="残差连接和层归一化"><a href="#残差连接和层归一化" class="headerlink" title="残差连接和层归一化"></a>残差连接和层归一化</h4><p>LayerNorm(F(x)+x)<br>残差链接可以用来解决梯度消失的问题，因为用反向传播时用链式法则求导之后提取公因子，括号里面有个1+一大串，这里的1保证了无论一大串多复杂，总梯度不会趋近于0  </p><h4 id="Mask-Self-Attention"><a href="#Mask-Self-Attention" class="headerlink" title="Mask Self-Attention"></a>Mask Self-Attention</h4><p>在transformer中，通常一次只预测一个词，因此未来的词不应该影响当前词的预测。所以对之后的词要加入mask，防止模型提前看到“答案”。  </p><h4 id="BCEWithLogitsLoss"><a href="#BCEWithLogitsLoss" class="headerlink" title="BCEWithLogitsLoss"></a>BCEWithLogitsLoss</h4><p>nn.BCEWithLogitsLoss 是 PyTorch 中用于二分类任务的一种损失函数，它将 sigmoid 激活和二元交叉熵损失结合在一起。使用 BCEWithLogitsLoss 的主要好处是，它可以直接处理未经过 sigmoid 激活的模型输出，从而提高数值稳定性。</p><h5 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h5><p>outputs &#x3D; torch.tensor([[0.5], [-1.0], [2.0]])  # 模型输出<br>targets &#x3D; torch.tensor([[1.0], [0.0], [1.0]])    # 真实标签</p><h5 id="计算损失"><a href="#计算损失" class="headerlink" title="计算损失"></a>计算损失</h5><p>loss &#x3D; criterion(outputs, targets)<br>print(loss.item())  # 输出损失值</p><p>Q: 我有一个二分类的任务，batch_size&#x3D;8,outputs.logits的形状是[8,2]，labels的形状是[8]， loss &#x3D; criterion(outputs.logits, labels)这行代码该如何修改，来计算损失？</p><p>A: 将 outputs.logits 的形状从 [8, 2] 变为 [8, 1]，你可以使用 outputs.logits[:, 1] 选择第二个类别的 logits。nn.BCEWithLogitsLoss 会在内部应用 sigmoid 函数，将 logits 转换为概率。对于二分类问题，Sigmoid 输出的范围在 [0, 1]，代表样本属于某个类别的概率。在许多情况下，我们关注的是样本属于类别 1 的概率，即 outputs.logits[:, 1] 通过 sigmoid 函数转换后的概率。</p><p>也可以选择第一个类别的 logits（outputs.logits[:, 0]），然后计算样本属于类别 0 的概率。这里的选择只是取决于你想关心哪个类别的概率。可以通过以下方式计算类别 0 的概率，并将标签进行相应的转换：  </p><p>logits &#x3D; outputs.logits[:, 0]  # 选择类别 0 的 logits<br>loss &#x3D; criterion(logits, (1 - labels).float())  # 反转标签，计算类别 0 的损失</p><h4 id="nn-CrossEntropyLoss"><a href="#nn-CrossEntropyLoss" class="headerlink" title="nn.CrossEntropyLoss"></a>nn.CrossEntropyLoss</h4><p>适用于 多分类 和 二分类 问题. 输入的 logits 通常是未经过 softmax 激活的直接输出，CrossEntropyLoss 会在内部自动对其进行 softmax 操作。  </p><p>outputs：模型输出的 logits，形状通常为 [batch_size, num_classes]。<br>labels：真实标签，形状为 [batch_size]，每个值表示分类的索引（例如，0 到 num_classes - 1 之间的整数）。</p><h6 id="示例数据-1"><a href="#示例数据-1" class="headerlink" title="示例数据"></a>示例数据</h6><p>outputs &#x3D; torch.tensor([[0.2, 2.3, 0.8], [1.2, 0.3, 0.5]])  # 模型输出 (batch_size&#x3D;2, num_classes&#x3D;3)<br>labels &#x3D; torch.tensor([1, 0])  # 真实标签 (batch_size&#x3D;2)</p><h6 id="计算损失-1"><a href="#计算损失-1" class="headerlink" title="计算损失"></a>计算损失</h6><p>loss &#x3D; criterion(outputs, labels)<br>print(loss.item())  # 输出损失值</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++常用语法</title>
    <link href="/2024/08/23/C++%20Note/"/>
    <url>/2024/08/23/C++%20Note/</url>
    
    <content type="html"><![CDATA[<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>原理：红黑树  </p><ul><li>头文件</li></ul><p>#include <map></p><ul><li>创建<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::map&lt;KeyType, ValueType&gt; mapName;  <br>std::map&lt;KeyType, ValueType&gt; mapName= &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>&#125;,&#123;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;two&quot;</span>&#125;&#125;;  <br></code></pre></td></tr></table></figure></li><li>插入元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 使用insert方法</span><br>myMap.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, std::string&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>));<br>myMap.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;two&quot;</span>));<br><span class="hljs-comment">// 使用下标运算符</span><br>myMap[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;three&quot;</span>;<br></code></pre></td></tr></table></figure></li><li>访问<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 使用下标运算符</span><br>std::cout &lt;&lt; myMap[<span class="hljs-number">1</span>] &lt;&lt; std::endl;<br><span class="hljs-comment">// 使用迭代器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>    std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>如果在使用迭代器时想记录循环次数，可以另外加变量解决  </li><li>查找<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 使用find方法，返回一个迭代器指向找到的元素，如果没有找到，则返回map::end</span><br>std::map&lt;<span class="hljs-type">int</span>, std::string&gt;::iterator it = myMap.<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (it != myMap.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-comment">// 找到了元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Found: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 没有找到元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Element not found&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>排序</li></ul><ol><li>结构体运算符重载<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> score;<br>string name;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> node &amp;s)<span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">if</span>(score!=s.score)<span class="hljs-keyword">return</span> score&gt;s.score;<br>        <span class="hljs-keyword">return</span> name&gt;s.name;<br>&#125;<br>&#125;node;<br></code></pre></td></tr></table></figure></li><li>修改map排序规则<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 自定义比较函数对象</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rule</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; a, <span class="hljs-type">const</span> std::string&amp; b)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">length</span>() &lt; b.<span class="hljs-built_in">length</span>(); <span class="hljs-comment">// 按字符串长度升序排序</span><br>    &#125;<br>&#125;;<br>std::map&lt;std::string, <span class="hljs-type">int</span>, Rule&gt; myMap; <span class="hljs-comment">// 定义时候最后加上规则</span><br></code></pre></td></tr></table></figure><blockquote><p>基于红黑树，本身map中的key就是有序的。查找key的效率O(logn)</p></blockquote></li></ol><h4 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h4><p>原理：哈希表<br>查找插入删除效率：O(1)，比基于红黑树的map的效率O(logn)更快<br><strong>所有操作同map</strong>  </p><blockquote><p>std::unordered_map 本身并不是排序的，它的元素是通过哈希函数存储在哈希表中的，而不是按照键的顺序排列。因此，如果想按照键的顺序遍历，需要使用map  </p></blockquote><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>有多种方法，建议写到结构体或类内部</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> score;<br>string name;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> node &amp;s)<span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">if</span>(score!=s.score)<span class="hljs-keyword">return</span> score&gt;s.score;<br>        <span class="hljs-keyword">return</span> name&gt;s.name;<br>&#125;<br>&#125;node;<br></code></pre></td></tr></table></figure><p><strong>对于A operator+(const A&amp; a)const {…}而言</strong><br>const A&amp; a：<br>这是函数的参数列表，其中 a 是一个引用参数，类型为 A 的常量引用。const 关键字表示在函数内部不能修改 a 引用的对象。使用引用而不是值传递可以避免不必要的对象拷贝，提高效率。<br>const：<br>这个 const 出现在参数列表后面，表示这个成员函数不会修改调用它的对象（即 this 指针所指向的对象）。这样的成员函数被称为常量成员函数。  </p><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>字符串，可以当作字符数组访问修改。有时也可以把string作为栈使用。<br>std::string str1 &#x3D; “hello”; std::string str3 &#x3D; str1; &#x2F;&#x2F; 复制 str1 中的内容到 str3  </p><ul><li>查找<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 查找子串首次出现的位置, size_t有的在#include&lt;cstddef&gt;，有的本来就有</span><br><span class="hljs-type">size_t</span> pos = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;C++&quot;</span>);<br><span class="hljs-keyword">if</span> (pos != std::string::npos) <span class="hljs-comment">//如果找到就打印 ，==npos就是找不到</span><br>&#123;    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;&#x27;C++&#x27; found at position: &quot;</span> &lt;&lt; pos &lt;&lt; std::endl;<br>&#125; <br><span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;&#x27;C++&#x27; not found.&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>子串<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 提取子字符串</span><br>std::string sub = str.<span class="hljs-built_in">substr</span>(pos, <span class="hljs-number">3</span>); <span class="hljs-comment">// 从位置 pos 开始，提取 3 个字符</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Substring extracted: &quot;</span> &lt;&lt; sub &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></li><li>替换<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 替换字符串中的某些部分</span><br>str.<span class="hljs-built_in">replace</span>(pos, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;Java&quot;</span>); <span class="hljs-comment">// 用 &quot;Java&quot; 替换 &quot;C++&quot;</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;String after replace: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></li><li>插入<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在指定位置插入字符串</span><br>str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">7</span>, <span class="hljs-string">&quot;beautiful &quot;</span>); <span class="hljs-comment">// 在位置 7 插入 &quot;beautiful &quot;</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;String after insert: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></li><li>删除<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 删除字符串中的某些部分</span><br>str.<span class="hljs-built_in">erase</span>(<span class="hljs-number">7</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// 从位置 7 开始，删除 10 个字符</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;String after erase: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></li><li>获取长度<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获取字符串长度</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;String length: &quot;</span> &lt;&lt; str.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></li><li>比较字符串<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 比较两个字符串</span><br>std::string str2 = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-type">int</span> result = str.<span class="hljs-built_in">compare</span>(str2); <span class="hljs-comment">//此函数的功能和C语言的strcmp（）一样，但用法有差异</span><br><span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;str is equal to str2&quot;</span> &lt;&lt; std::endl;<br>&#125; <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) <br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;str is less than str2&quot;</span> &lt;&lt; std::endl;<br>&#125; <br><span class="hljs-keyword">else</span> <br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;str is greater than str2&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>追加<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在字符串末尾追加内容</span><br>str.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot; Welcome!&quot;</span>); <span class="hljs-comment">//此函数实现得有些冗余，其实+=和这个函数实现的效果完全一样（个人更喜欢用+= 简单）</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;String after append: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></li><li>使用迭代器遍历&#x2F;修改<br>迭代器的底层还是指针  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 修改字符串中的字符</span><br><span class="hljs-keyword">for</span> (string::iterator it = str.<span class="hljs-built_in">begin</span>(); it != str.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>    <span class="hljs-keyword">if</span> (*it == <span class="hljs-string">&#x27;C&#x27;</span>) &#123;<br>        *it = <span class="hljs-string">&#x27;D&#x27;</span>;  <span class="hljs-comment">// 修改 &#x27;C&#x27; 为 &#x27;D&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="set和unordered-set"><a href="#set和unordered-set" class="headerlink" title="set和unordered_set"></a>set和unordered_set</h4><p>类似于map和unordered_map，set底层是红黑树，查找插入删除效率O(logn)，unordered_set底层是哈希表，查找插入删除效率O(1).  </p><blockquote><p>此外，对于map和set，可以用count来代替find</p></blockquote><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p>std::stack<int> stk(10, 0); &#x2F;&#x2F; 创建一个包含10个0的stack</p><p>int top &#x3D; stk.top(); &#x2F;&#x2F; 获取stack顶部的元素</p><p>bool empty &#x3D; stk.empty(); &#x2F;&#x2F; 检查stack是否为空</p><p>stk.push(42); &#x2F;&#x2F; 在stack的顶部添加一个元素</p><p>stk.push(42); &#x2F;&#x2F; 在stack的顶部添加一个元素</p><p>stk.pop(); &#x2F;&#x2F; 删除stack顶部的元素</p><p>stk.top() &#x3D; 42; &#x2F;&#x2F; 修改stack顶部的元素</p><p>bool contains &#x3D; stk.contains(42); &#x2F;&#x2F; 检查stack中是否包含值为42的元素</p><p>stk.sort(); &#x2F;&#x2F; 默认根据元素值进行升序排序</p><p>size_t size &#x3D; stk.size(); &#x2F;&#x2F; 获取stack中的元素数量</p><p>size_t capacity &#x3D; stk.capacity(); &#x2F;&#x2F; 获取stack的容量</p><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><ul><li><p>复制<br>vector<T> v2(v1); &#x2F;&#x2F;v2中包含v1所有元素的副本<br>vector<T> v2&#x3D;v1; &#x2F;&#x2F;等价于v2(v1)</p></li><li><p>初始化定义<br>vector<int> a(10, 1) ; &#x2F;&#x2F;定义一个初始大小为 10 且初始值都为 1 的向量</p></li></ul><p>v.size() &#x2F;&#x2F;返回向量v中的元素个数</p><p>v.empty() &#x2F;&#x2F;若v中不包含任何元素，返回真；否则返回假</p><p>v.push_back(t) &#x2F;&#x2F;向v的尾端添加一个值为t的元素</p><p>v.front() &#x2F;&#x2F;访问v的第一个元素</p><p>v.back() &#x2F;&#x2F;访问v的最后一个元素</p><p>push_back() &#x2F;&#x2F;把传送为参数的对象添加到vector的尾部</p><p>pop_back() &#x2F;&#x2F;删除vector尾最后一个元素</p><p>v.erase(v.begin()) &#x2F;&#x2F;将起始位置的元素删除</p><p>v.erase(v.begin(), v.begin()+3) &#x2F;&#x2F;将(v.begin(), v.begin()+3)之间的3个元素删除</p><p>v.erase(v.begin() + 3) &#x2F;&#x2F;删除第4个元素</p><p>clear() &#x2F;&#x2F;清除所有元素</p><p>insert() &#x2F;&#x2F;插入一个或多个对象</p><p>v.insert(v.begin(), 1000); &#x2F;&#x2F;将1000插入到向量v的起始位置前</p><p>v.insert(v.begin() + 1,9); &#x2F;&#x2F;在第二个位置插入新元素</p><p>v.insert(v.begin(), 3, 1000) &#x2F;&#x2F;位置0开始，连续插入3个1000</p><p>v.insert(v.begin()+1, 7,8) &#x2F;&#x2F;位置1开始，连续插入7个8</p><h4 id="string-1"><a href="#string-1" class="headerlink" title="string"></a>string</h4><ol><li><p>在字符串指定位置插入字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s = <span class="hljs-string">&quot;123&quot;</span>;<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;@&quot;</span>);<span class="hljs-comment">//第一个参数是插入的位置下标，第二个是插入的字符串</span><br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;###&quot;</span>);<br>cout &lt;&lt; s &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>输出：@###123</p></li><li><p>删除字符串中的所有指定字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i=s.<span class="hljs-built_in">find</span>(x);<br> <span class="hljs-keyword">while</span>(i!=string::npos)<span class="hljs-comment">//-1</span><br> &#123;<br>     s.<span class="hljs-built_in">erase</span>(i,x.<span class="hljs-built_in">length</span>());<br>     i=s.<span class="hljs-built_in">find</span>(x);<br> &#125;<br><span class="hljs-function">string&amp; <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos=<span class="hljs-number">0</span>, <span class="hljs-type">size_t</span> len = npos)</span></span>;<br></code></pre></td></tr></table></figure></li></ol><p>其中，参数pos表示要删除字符串的起始位置，其默认值是0；len表示要删除字符串的长度，其默认值是string::npos。返回值是删除后的字符串。</p><ol start="3"><li><p>替换字符串中的所有指定字符<br>法一、for循环直接赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;s.<span class="hljs-built_in">length</span>();k++)<br>     <span class="hljs-keyword">if</span>(s[k]==x)<br>         s[k]=y;<br> cout&lt;&lt;<span class="hljs-string">&quot;Replace-&gt;&quot;</span>&lt;&lt;s&lt;&lt;endl;<br></code></pre></td></tr></table></figure><p>法二、algorithm里面的replace函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s = <span class="hljs-string">&quot;121145&quot;</span>;<br>    <span class="hljs-comment">//char a = &#x27;1&#x27;;</span><br>    <span class="hljs-built_in">replace</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;#&#x27;</span>);<br>    cout &lt;&lt; s &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li><li><p>输出字符串的长度<br>s.length();<br>s.size();</p></li><li><p>反转输出字符串（这一步仅输出，不改变字符串）<br>法一、for循环输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=s.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;k&gt;=<span class="hljs-number">0</span>;k--)<br>     cout&lt;&lt;s[k];<br> cout&lt;&lt;endl;<br></code></pre></td></tr></table></figure><p>法二、reverse函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>;<br><span class="hljs-built_in">reverse</span>(s2.<span class="hljs-built_in">begin</span>(), s2.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//头文件是不是也在算法里面？</span><br>cout &lt;&lt; s2 &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li></ol><p>6、输出字符串从位置i到j的子串<br>法一、for循环<br>cin&gt;&gt;i&gt;&gt;j;<br>cout&lt;&lt;”Sub-&gt;”;<br>for(int k&#x3D;i;k&lt;&#x3D;j;k++)<br>     cout&lt;&lt;s[k];<br> cout&lt;&lt;endl;</p><p>法二、substr函数<br>int a, b;<br>cin &gt;&gt; a;<br>cin &gt;&gt; b;</p><p>string t &#x3D; s1.substr(a, b-a+1);<br>cout&lt;&lt;”Sub-&gt;”;<br>cout &lt;&lt; t &lt;&lt; endl;<br>7、匹配子串，输出首次匹配到子串的第一个字符位置<br>法一、手动输出-1<br>cin&gt;&gt;st;&#x2F;&#x2F;string st<br>if(s.find(st)!&#x3D;string::npos)<br>     cout&lt;&lt;”Find-&gt;”&lt;&lt;s.find(st)&lt;&lt;endl;<br>else<br>     cout&lt;&lt;”Find-&gt;-1”&lt;&lt;endl;<br>cout&lt;&lt;endl;</p><p>法二、find没匹配到会自己变成-1<br>string a;<br>cin &gt;&gt; a;<br>int x &#x3D; -1;<br>x &#x3D; s1.find(a);<br>cout&lt;&lt;”Find-&gt;”;<br>cout &lt;&lt; x &lt;&lt; endl;</p><p>8、补充<br>1 .string的定义和初始化：<br>（1）string s1; —&gt; &#x2F;&#x2F; 默认初始化，s1是一个空字符串<br>（2）string s2 &#x3D; s1; —&gt; &#x2F;&#x2F; s2是s1的副本，注意s2只是与s1的值相同，并不指向同一段地址<br>（3）string s3 &#x3D; “hiya”; —&gt; &#x2F;&#x2F; s3是该字符串字面值的副本<br>（4）string s4(10, ‘c’); —&gt; &#x2F;&#x2F; s4的内容是: “cccccccccc”</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客开篇：关于这座岛</title>
    <link href="/2023/12/23/post/"/>
    <url>/2023/12/23/post/</url>
    
    <content type="html"><![CDATA[<h2 id="博客开篇：关于这座岛"><a href="#博客开篇：关于这座岛" class="headerlink" title="博客开篇：关于这座岛"></a>博客开篇：关于这座岛</h2><p>这是第一篇文章，记录该博客的出现。  </p><h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><p>离那个时代越来越远，社交网络中的人越来越多，多数从未见过，部分一面之缘。</p><p>科技的发展令人赞叹，但变得飞快的不只有高铁的速度，还有人们的生活。现在学习叫速成，咖啡叫续命，上班叫996，旅行叫特种兵。上学为了分数，上班为了赚钱，人们匆忙地走过一切，然后再匆忙地走向另一切，为了完成一个目标，然后再完成另一个。  </p><h5 id="2"><a href="#2" class="headerlink" title="2"></a>2</h5><p>曾经的个人博客撑起了互联网内容，没有功利，没有资本，没有套路，没有大公司。慢慢地，纯粹的沉淀开始打不过短平快，博客逐渐没落。  </p><p>我并不反对两个时代的差异，我接受并拥抱今天的一切。那么为什么要搭建这个博客，原因之一当然是最近几天闲着没事干，恰好对此有些兴趣，故进行尝试。  </p><p>此外，我常常一时想不起过去的某段时间我都干了些什么，我也常常忘记曾经查过的某个函数该怎么用，希望自己闲来无事时在此进行记录，成篇的内容归纳在一起，方便浏览。如果还能给来到这里的旅行者带来一点趣味，也是这座孤岛存在的价值。<del>当然，如果上天垂怜我，在我拥有一个离谱的访问量之后，我甚至可以放广告赚米。</del>  </p><h5 id="3"><a href="#3" class="headerlink" title="3"></a>3</h5><p>我只是玩一玩的心态，just for fun. 目前功能还很简单，之后使用过程中再完善，我大概的确会吧。  </p><p>现在是2023年12月23日下午5点27分，朋友们应该即将结束第一天的考试，希望他们顺利。</p>]]></content>
    
    
    <categories>
      
      <category>札记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
